---
layout:     post
title:      "MySQL 数据库"
subtitle:   "Hello World, Hello Blog"
date:       2020-12-04
author:     "Caiiiiii"
catalog:    true
header-img: "img/steam12-9-1.jpg"
tags:
    - MySQL
    - 数据库  
---

# MySQL
MySQL 是一种关系型数据库，在Java企业级开发中非常常用，MySQL的默认端口号是3306。



## 存储引擎
MySQL 5.5版本前的默认的存储引擎是MyISAM ，MySQL 5.5版本后的默认的存储引擎是InnoDB

### 两者存储引擎的区别

 - 是否支持行级锁：MyISAM只有表级锁，InnoDB有表级锁和行级锁
 - 是否支持事务和崩溃后d的安全恢复：MyISAM强调的是性能，不支持事务。InnoDB提供事务支持，外部键等高级操作，具有事务、回滚、崩溃修复功能的事务安全形表。
 - 是否支持外键：MyISAM不支持，InnoDB支持。

 ## 索引
MySQL索引使用的数据结构主要有BTree索引 和 哈希索引 。
单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。


## 什么是事务?
事务是逻辑上的一组操作，要么都执行，要么都不执行。

### 事务的四大特性(ACID)
 - 原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
 - 一致性（Consistency）： 执行事务后，数据库从一个正确的状态变化到另一个正确的状态；
 - 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
 - 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。


## 并发事务带来哪些问题?
 - 脏读： 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
 - 丢失修改：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
 - 不可重复读：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
 - 幻读：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

## 事务隔离级别有哪些?MySQL的默认隔离级别是?
 - READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
 - READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
 - REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
 - SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。


## MySQL 优化

 - 优化SQL语句和索引

 - 加缓存,memcached,redis;

 - 在应用层实现主从复制，读写分离：1.在应用层实现。2.数据库中间件实现。

 - MySQL自带分区表。将表进行分区。

 - 垂直拆分，将一个大的系统拆分为多个小的系统。

 - 最后是水平切分


# 能说下myisam 和 innodb的区别吗？
 myisam是5.1版本前的引擎，不支持事务和行级锁，不支持外键，索引和数据是分开存储的。  
 innodb是聚簇索引建立的，能和myisam 相反支持事务，外键。

# mysql的索引有哪些
索引按照数据结构来说主要包含
 - B+树索引
 - Hash索引

按照类型有：
 - 普通索引
 - 唯一索引
 - 主键索引
 - 组合索引
 - 全文索引

# 聚簇索引和非聚簇索引又是什么？
B+树是左小右大的顺序存储结构，节点只包含id索引列，而叶子节点包含索引列和数据，这种数据和索引在一起存储的索引方法叫做聚簇索引。一张表只能有一个聚簇索引。

而Myisam中的叶子节点存储的是索引+指向数据的逻辑指针

![jucusuoyin](/img/jucusuoyin.jpg)


# 什么是覆盖索引和回表
覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。

# MySQL 锁的类型
mysql 锁分为读锁和写锁  
- 读锁是共享的，这时候只能读不能写  
- 写锁是排他的，他会阻碍其他写锁和读锁，从颗粒度区分，可以分为表锁和行锁。
    - 表锁会锁住整张表并阻塞其他用户对该表的所有读写操作
    - 行锁分为乐观锁和悲观锁，悲观锁可以通过for update 实现，乐观锁通过版本号实现


# MySQL事务的基本特性和隔离级别
事务：是指程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，缶而每个操作中所有的改动都会被撤销。

基本特性ACID分别为：  
原子性（Atomicity）指一个事务中要么全部成功，要么全部失败。  
一致性（Consistency）指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。  
隔离性（Isolation）指的是一个事务的修改在最终提交前，对其他事务都是不可见的。  
持久性（Durability）指的是一旦事务提交，所做的修改就会永久保存在数据库中。 

隔离性有4个隔离级别：  
read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫脏读。  
read commit  读已提交，两次读取结果不一致，叫做不可重复读。 
 - 不可重复读:在同一事物中同一查询读取到不同结果。（强调一条数据中的列值被修改）  
repeatable read（mysql 默认级别） 可重复读，就是每次读取结果都一样，但是有可能产生幻读。  
 - 幻读：指的是在同一事务下，连续执行两次同样的SQL语句第二次的SQL语句可能返回之前不存在的行。  （强调读取一个范围内的记录结果不同）  
serializable ：序列化读，两段式提交的第一步，要在事务开始的时候，原子性的把需要的锁全部加好，在事务结束前最后时刻，把全部锁一次性释放。  


# ACID靠什么保证
A原子性由日志保证，记录了需要回滚的日志信息，回滚时撤销已经执行的sql  
C一致性靠代码层保证  
I隔离性由MVCC保证  
D持久性由内存和日志保证。修改数据同时在内存和日志记录，宕机时候可以从内存恢复  

# 什么是MVCC
MVCC叫做多版本并发控制，实际就是保存了数据在某个时间节点的快照。

我们每行数实际上隐藏了两列，创建时间版本号，过期(删除)时间版本号，每开始一个新的事务，版本号都会自动递增。  
MVCC的原理是查找创建版本小于或等于当前事务版本，删除版本为空或者大于当前事务版本。   

# 什么是间隙锁？
间隙锁是可重复读级别下才会有的锁，结合MVCC和间隙锁可以解决幻读的问题。
表的间隙mysql自动帮我们生成了区间(左开右闭)上锁。（唯一索引不会有间隙索引的）


# 分库分表怎么做的
- 垂直分库
- 垂直分表
- 水平分表

## 分库分表ID一致性
- UUID
- Twitter的Snowflake分布式自增ID算法，生成64位Long型数字。
   - 1位标识符：始终是0
   - 41位时间戳，是存储时间截的差值（当前时间截 - 开始时间截 )得到的值
   - 10位机器标识码
   - 12位序列

- 分表后不使用逐渐作为查询依据，用一个字段作为唯一主键使用，如订单号。

# mysql 主从同步是怎么做到的？
mysql主从同步的原理  
1.master提交事务后，写入binlog    
2.slave链接master，获取binlog    
3.master创建dump线程，推送binlog到slave  
4.slave创建一个IO线程读取同步过来的master的binlog，记录到relaylog中继日志中  
5.salve再开启一个sql线程读取relay log时间并在salve执行，完成同步  
6.salve记录自己的binlog  

![sqlzhucong.jpg](/img/sqlzhucong.jpg)

由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。  

### 全同步复制
主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。

### 半同步复制
和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。


# 主从的延迟怎么解决呢？
并行复制，开启多个线程，并行读取relay log不同库的日志，然后并行执行sql线程。（不同库事务没有锁冲突）

- 分库，将主库拆分为多个主库，减少并发
- 并行复制
- 重写代码，插入数据时立马查询可能查不到。
-如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库。


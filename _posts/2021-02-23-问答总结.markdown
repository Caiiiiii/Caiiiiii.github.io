---
layout:     post
title:      "问答总结"
subtitle:   "Hello World, Hello Blog"
date:       2021-02-23
author:     "Caiiiiii"
header-img: "img/1174180_screenshots_20201019222158_1.jpg"
tags:
    - Spring
    - Java  
---

# HashMap 和 HashTable 之间的区别
## HashMap
1.由数组+链表组成，链表则是主要为了解决哈希冲突而存在的。
ps:jdk1.8后当单个链表超过8个时候变成红黑树。
2.不是线程安全的，HashMap可以接受为null的键和值。
3.初始size为16，当Map中元素超过Entry数组的75%，触发扩容操作，每次扩容是上次的2倍
4.HashMap继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。
5.HashMap添加元素时，是使用自定义的哈希算法。

## Hashtable
1.由数组+链表组成。
2.是线程安全的，无论Key和value都不能为null，实现线程安全的方法是修改数据时锁住整个HashTable，效率低。
3.初始size为11，扩容：newsize = olesize*2+1。
4.Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。
5.Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。


# HashMap 为什么是线程不安全的？想要线程安全如何做？
jdk1.7 是因为数组扩容的原因，当并发执行扩容操作时会造成环形链和数据丢失情况。
jdk1.8 是因为HashMap在并发情况下执行put方法时会进行是否发生hash碰撞的判断，如果线程抢断，会发生数据覆盖的情况。
![HashMap 为什么是线程不安全的](https://blog.csdn.net/zzu_seu/article/details/106669757)


使用 java.util.Hashtable 类，此类是线程安全的。
使用 java.util.concurrent.ConcurrentHashMap，此类是线程安全的。
使用 java.util.Collections.synchronizedMap () 方法包装 HashMap object，得到线程安全的 Map，并在此 Map 上进行操作。




# SpringMVC 原理
SpringMVC 原理就是SpringMVC 工作流程

1.用户发送请求至前端控制器DispatcherServlet。
2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。
3.处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
4.DispatcherServlet调用HandlerAdapter处理器适配器。
5.HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。
6.Controller执行完成返回ModelAndView。
7.HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。
8.DispatcherServlet将ModelAndView传给ViewReslover视图解析器。
9.ViewReslover解析后返回具体View。
10.DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。
11.DispatcherServlet响应用户。


### 简略点的版本
![](img/springmvc.png)


# 多用连表查询

# Mybatis 是如何防止SQL注入？
1.Mybatis中使用#可以防止SQL注入，$并不能防止SQL注入
2.#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。$将传入的数据直接显示生成在sql中。
3.Mybatis实现SQL注入的原理是调用了jdbc中的PreparedStatement来进行预处理。

# 拦截器的实现

1.UserInterceptor配置类继承HandlerInterceptor类重写preHandle，postHandle ，afterCompletion方法。

## springboot 
springboot 中的拦截器配置类InterceptionConfig 继承了WebMvcConfigurer类 ，在addInterceptors注册UserInterceptor类并添加需要拦截的请求。

## springmvc
springmvc 则是在springmvc-config.xml文件中添加<mvc:interceptor>标签注册UserInterceptor 并添加需要拦截的请求。

# 二分法查找
```
private static int findIndex2(int[] arr, int ele) {
        int minIndex=0;
        int maxIndex=arr.length-1;
        int midIndex=(minIndex+maxIndex)/2;
        while (minIndex <= maxIndex){
            //如果要查的元素,正好等于中间索引所对应的元素 直接返回这个中间索引
            if (ele == arr[midIndex]) {
                return midIndex;
                //如果你要查找的元素比中间索引所对应的元素大 那么就动最小索引
            } else if (ele > arr[midIndex]) {

                minIndex = midIndex + 1;
                //如果你要查找的元素比中间索引所对应的元素小,那么你就动最大索引
            } else if (ele < arr[midIndex]) {
                maxIndex = midIndex - 1; 
            }
            //再重新计算中间索引
            midIndex = (minIndex + maxIndex) / 2;
        }
        return -1;
    }

```

# 用两个线程求 1 + 100的和
```
public class ThreadSum {
    public static void main(String[] args) {
         ThreadMethod t1 = new ThreadMethod();
         ThreadMethod t2 = new ThreadMethod();
         t1.run();
         t2.run();
    }
}
class  ThreadMethod implements  Runnable{
    static int sum = 0 ;
    static int num = 1;
    @Override
    public synchronized void run() {
        while ( num <= 100){
            sum+=num;
            num++;
        }
        if (num>100){
            System.out.println(sum);
        }
    }
}
```


# 线程池的实现原理

## 基本概念
- 核心线程数：指的是线程池的基本大小
- 最大线程数： 指的是，同一时刻线程池中线程的数量最大不能超过该值
- 任务队列： 是当任务较多时，线程池中线程的数量已经达到了核心线程数，这时候就是用任务队列来存储我们提交的任务。 与其他池化技术不同的是，线程池是基于生产者-消费者模式来实现的，任务的提交方是生产者，线程池是消费者

## 流程
![](img/threadpool.jpg)
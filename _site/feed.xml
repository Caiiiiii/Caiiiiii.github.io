<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Caiiiiii Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 15 May 2020 18:09:04 +0800</pubDate>
    <lastBuildDate>Fri, 15 May 2020 18:09:04 +0800</lastBuildDate>
    <generator>Jekyll v4.0.1</generator>
    
      <item>
        <title>为什么这是错误的</title>
        <description>&lt;h1 id=&quot;元字符&quot;&gt;元字符&lt;/h1&gt;
&lt;h3 id=&quot;匹配字符&quot;&gt;匹配字符&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;.  ：匹配除换行符意外的任意字符&lt;/li&gt;
  &lt;li&gt;\w ：匹配字母或数字或下划线或汉字&lt;/li&gt;
  &lt;li&gt;\s : 匹配任意的空白符&lt;/li&gt;
  &lt;li&gt;\d ：匹配数字&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;匹配位置&quot;&gt;匹配位置&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;\b ：匹配单词的开始或结束&lt;/li&gt;
  &lt;li&gt;^  : 匹配字符串的开始&lt;/li&gt;
  &lt;li&gt;$  : 匹配字符串的结束&lt;/li&gt;
  &lt;li&gt;\G : 上一个匹配结尾（本次匹配开始）&lt;/li&gt;
  &lt;li&gt;\A : 字符串开头（类似 ^,但不受处理多行选项的影响）&lt;/li&gt;
  &lt;li&gt;\Z : 字符串结尾或行尾（不受处理多行选项的影响）&lt;/li&gt;
  &lt;li&gt;\z : 字符串结尾（类似$，但不受处理多行选项的影响）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;重复&quot;&gt;重复&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;* : 重复零次或者更多次&lt;/li&gt;
  &lt;li&gt;+ ：重复一次或者更多次&lt;/li&gt;
  &lt;li&gt;?  : 重复零次或者一次&lt;/li&gt;
  &lt;li&gt;{n} : 重复n次&lt;/li&gt;
  &lt;li&gt;{n,} : 重复n次或更多次&lt;/li&gt;
  &lt;li&gt;{n,m} ：重复n到m次&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;字符转义&quot;&gt;字符转义&lt;/h1&gt;

&lt;p&gt;如果想匹配元字符本身或者正则中的一些特殊字符，使用 \ 转义。例如 匹配 * 这个字符则使用 \* ,匹配 \ 这个字符，使用 \\ 。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;需要转义的字符 ： $ , ( , ) , * , + , . , [ , ] , ? , \ , ^ , { , } ,&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;字符类&quot;&gt;字符类&lt;/h1&gt;
&lt;p&gt;当需要匹配明确的字符或字符集合的时候，就用到字符类。&lt;/p&gt;
&lt;h3 id=&quot;特殊字符&quot;&gt;特殊字符&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;\0hh : 8进制值hh所表示的字符&lt;/li&gt;
  &lt;li&gt;\xhh : 16进制值hh锁表示的字符&lt;/li&gt;
  &lt;li&gt;\uhhhh : 16进制值hhhh所表示的Unicode字符&lt;/li&gt;
  &lt;li&gt;\t : tab&lt;/li&gt;
  &lt;li&gt;\n : 换行符&lt;/li&gt;
  &lt;li&gt;\r : 回车符&lt;/li&gt;
  &lt;li&gt;\f  : 换页符&lt;/li&gt;
  &lt;li&gt;\e : Escape&lt;/li&gt;
  &lt;li&gt;\CN : ASCII控制字符。比如\cC 代表 Ctrl+C&lt;/li&gt;
  &lt;li&gt;\p{name} : Unicode 中命名为name的字符类，例如 \p{IsGreek}&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;陈列&quot;&gt;陈列&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[aeiou] ： 匹配一个元音字符&lt;/li&gt;
  &lt;li&gt;[.?!] ： 匹配给定的一个标点&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;范围&quot;&gt;范围&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[0-9] : 匹配0~9的数字，同 \d&lt;/li&gt;
  &lt;li&gt;[a-z] : 匹配所有小写字母&lt;/li&gt;
  &lt;li&gt;[a-zA-Z] : 匹配所有字母&lt;/li&gt;
  &lt;li&gt;[a-z0-9A-Z_] : 等同于 \w&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;反义&quot;&gt;反义&lt;/h1&gt;
&lt;h3 id=&quot;反义元字符&quot;&gt;反义元字符&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;\W ：匹配任意不是字母、数字、下划线、汉字的字符&lt;/li&gt;
  &lt;li&gt;\S ：匹配任意不是空白符的字符&lt;/li&gt;
  &lt;li&gt;\D : 匹配任意非数字的字符&lt;/li&gt;
  &lt;li&gt;\B : 匹配不是单词开头或结束的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;反义字符类&quot;&gt;反义字符类&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[^x] : 匹配除了x以外的任意字符&lt;/li&gt;
  &lt;li&gt;[^aeiou] : 匹配除了aeiou这几个字母以外的任意字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;分支条件&quot;&gt;分支条件&lt;/h3&gt;
&lt;p&gt;又叫逻辑运算符，在此 X 和 Y 表示两个表达式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;XY ： X紧跟Y&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;X&lt;/td&gt;
          &lt;td&gt;Y ： 表示X或Y，从左到右，满足第一个条件就不会继续匹配了&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;分组&quot;&gt;分组&lt;/h1&gt;
&lt;p&gt;在这里我把表达式统一以\w 为例 ：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(\w) : 被一个括号包围起来是一个整体，表示一个分组&lt;/li&gt;
  &lt;li&gt;(\w)(\w) : 自动命名分组，第一个小括号是分组1，第二个小括号是分组2&lt;/li&gt;
  &lt;li&gt;(?’Word’\w+)) : 表示定义了一个叫做Word的分组&lt;/li&gt;
  &lt;li&gt;(?\w+)) : 表示定义了一个叫做Word的分组&lt;/li&gt;
  &lt;li&gt;(?:\w+) : 匹配exp，不捕获匹配的文本，也不给此分组分配组号&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;反向引用&quot;&gt;反向引用&lt;/h1&gt;
&lt;p&gt;后面的表达式可以引用前面的某个分组，用 \1 表示，就好像分组1的值赋值给了 \1 这个变量，这个变量可以在后面任意位置引用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\1 表示分组1匹配的文本&lt;/li&gt;
  &lt;li&gt;\k 表示分组 Word 匹配的文本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;匹配重复两个英文，例如匹配 Hello Hello 、 lei123 lei123:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(\w+)\s+\1&lt;/li&gt;
  &lt;li&gt;(?\w+)s+\k&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 15 May 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/05/15/zhengze/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/15/zhengze/</guid>
        
        <category>Web</category>
        
        <category>Dotnet</category>
        
        <category>译</category>
        
        <category>test</category>
        
        
      </item>
    
      <item>
        <title>VB 学习</title>
        <description>&lt;h1 id=&quot;aspnet-事件&quot;&gt;asp.net 事件&lt;/h1&gt;

&lt;h2 id=&quot;page_load&quot;&gt;Page_Load&lt;/h2&gt;
&lt;p&gt;Page_Load 事件会在页面加载时被触发，然后ASP.NET 会自动调用子例程Page_Load，并执行其中的代码。&lt;/p&gt;

&lt;p&gt;现在asp.net 事件格式如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Sub Page_Load(sender As Object, e As EventArgs) Handles MyBase.Load
    // content
  End Sub
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 15 May 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/05/15/vb.net/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/15/vb.net/</guid>
        
        <category>Web</category>
        
        <category>Dotnet</category>
        
        <category>译</category>
        
        
      </item>
    
      <item>
        <title>「译」ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？</title>
        <description>&lt;p&gt;JavaScript 有着很奇怪的命名史。&lt;/p&gt;

&lt;p&gt;1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript &lt;em&gt;（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-js-version/javascript-java.jpg&quot; alt=&quot;java-javascript&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;歪果仁的笑话怎么一点都不好笑&lt;/small&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注：&lt;a href=&quot;https://en.wikipedia.org/wiki/JavaScript#History&quot;&gt;wikipedia 的 JavaScript 词条&lt;/a&gt; 更详细的叙述了这段历史&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1996 年，网景将 JavaScript 提交给 &lt;a href=&quot;http://www.ecma-international.org/&quot;&gt;ECMA International（欧洲计算机制造商协会）&lt;/a&gt; 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;术语（译者注）：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;em&gt;标准（Standard）&lt;/em&gt;： 用于定义与其他事物区别的一套规则&lt;/li&gt;
    &lt;li&gt;&lt;em&gt;实现（Implementation）&lt;/em&gt;： 某个标准的具体实施/真实实践&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注：&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29&quot;&gt;ECMAScript 第四版草案&lt;/a&gt;由于太过激进而被抛弃，Adobe 的 &lt;a href=&quot;https://en.wikipedia.org/wiki/ActionScript&quot;&gt;ActionScript 3.0&lt;/a&gt; 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）&lt;/p&gt;

&lt;p&gt;目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 &lt;a href=&quot;https://github.com/wycats/javascript-decorators&quot;&gt;decorators（装饰者）&lt;/a&gt;，&lt;a href=&quot;https://github.com/lukehoban/ecmascript-asyncawait&quot;&gt;async-await（async-await 异步编程模型）&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/jeffmo/es-class-properties&quot;&gt;static class properties（静态类属性）&lt;/a&gt;。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 &lt;a href=&quot;https://babeljs.io/docs/usage/experimental/&quot;&gt;Babel 的官网&lt;/a&gt; 上查看各个提案目前都在哪个阶段了。&lt;/p&gt;

&lt;p&gt;所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript&lt;/strong&gt;：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;JavaScript&lt;/strong&gt;：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript 5 (ES5)&lt;/strong&gt;：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)&lt;/strong&gt;：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅&lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;这张兼容性表&lt;/a&gt;来查看不同浏览器和工具的实现情况。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript 2016&lt;/strong&gt;：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ECMAScript Proposals&lt;/strong&gt;：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。&lt;/p&gt;

&lt;h4 id=&quot;一些资源&quot;&gt;一些资源&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;TC39 的 &lt;a href=&quot;https://github.com/tc39/ecma262&quot;&gt;Github 仓库&lt;/a&gt;上可以看到所有目前公开的提案&lt;/li&gt;
  &lt;li&gt;如果你还不熟悉 ES6，Babel 有一个&lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;很不错的特性概览&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 &lt;a href=&quot;http://exploringjs.com/&quot;&gt;Exploring ES6&lt;/a&gt;和 Nicholas Zakas 的 &lt;a href=&quot;https://leanpub.com/understandinges6&quot;&gt;Understanding ECMAScript 6&lt;/a&gt;。Axel 的博客 &lt;a href=&quot;http://www.2ality.com/&quot;&gt;2ality&lt;/a&gt; 也是很不错的 ES6 资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img class=&quot;shadow&quot; width=&quot;320&quot; src=&quot;/img/in-post/post-js-version/keep-calm-and-learn-javascript.png&quot; /&gt;
&lt;small class=&quot;img-hint&quot;&gt;来学 JavaScript 吧！&lt;/small&gt;&lt;/p&gt;

&lt;h4 id=&quot;著作权声明&quot;&gt;著作权声明&lt;/h4&gt;

&lt;p&gt;本文译自 &lt;a href=&quot;http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/&quot;&gt;ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?&lt;/a&gt; &lt;br /&gt;
译者 &lt;a href=&quot;http://weibo.com/huxpro&quot;&gt;黄玄&lt;/a&gt;，首次发布于 &lt;a href=&quot;http://huangxuan.me&quot;&gt;Hux Blog&lt;/a&gt;，转载请保留以上链接&lt;/p&gt;

</description>
        <pubDate>Tue, 22 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/09/22/js-version/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/09/22/js-version/</guid>
        
        <category>Web</category>
        
        <category>JavaScript</category>
        
        <category>译</category>
        
        
      </item>
    
  </channel>
</rss>
